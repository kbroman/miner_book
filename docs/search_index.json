[
["index.html", "R Programming with Minecraft 1 Introduction", " R Programming with Minecraft Brooke Anderson, Karl Broman, Gergely Daróczi, Mario Inchiosa, David Smith, and Ali Zaidi 2017-06-05 1 Introduction Minecraft is awesome fun, especially in creative mode, where you can build all sorts of crazy stuff. But ambitious building projects can be really tedious to create by hand. With the miner R package, you can write R code to manipulate your Minecraft world and create even more awesome stuff. We developed the miner package and most of the examples in this book at the ROpenSci Unconference in Los Angeles, California, in May, 2017. We are grateful to ROpenSci for bringing us together. Our work on R and Minecraft was inspired by an example at http://smarterpoland.pl using R to make a 3D scatterplot in minecraft, and by Craig Richardson’s book Learn to Program with Minecraft (Richardson 2016). References "],
["installation.html", "2 Installation 2.1 Mac OS X 2.2 Windows 2.3 Docker 2.4 Raspberry Pi", " 2 Installation To use the miner package, you’ll need a Minecraft server that is using the RaspberryJuice plugin. You can Spigot to set up your own server, even locally on your machine. The installation process doesn’t take too long, but it helps to have some command line experience. 2.1 Mac OS X Installing stuff on a Mac. 2.2 Windows Installing stuff in Windows. 2.3 Docker Installing stuff via Docker. 2.4 Raspberry Pi Installing stuff on a Raspberry Pi. "],
["a-stairway-to-heaven.html", "3 A Stairway to Heaven 3.1 Building Objects 3.2 Stairway to heaven", " 3 A Stairway to Heaven 3.1 Building Objects The function to create objects in miner is the setBlock function. It expects four arguments, the first three being the coordinates of your item’s location, and the fourth being the block_id you want to set. An optional argument is block_style. First, you need to find out where you are. You can use getPlayerIds to get the ids of all players currently in the Minecraft world. You can use the getPlayerPos function to find the position of each player. If you are the first player, you can pull your ID as the first element of the object returned by getPlayerIds: ids &lt;- getPlayerIds() lapply(ids, getPlayerPos) ali &lt;- ids[1] 3.2 Stairway to heaven We will create a matrix that contains our increments. First we create a matrix with as many columns as we want stairs, and three rows specifying our coordinates. The coordinates are obtained by incrementing the first and second element of each column. We then use purrr:map to input that matrix to the setBlocks function. pos &lt;- getPlayerPos(player_id = ali, tile = TRUE) stair_blocks &lt;- 10 stepsize &lt;- 1 stairs &lt;- replicate(stair_blocks, pos) upset &lt;- cbind(rep(0, 3), replicate(stair_blocks - 1, c(1, 1, 0))) t_upset &lt;- t(apply(upset, 1, cumsum)) t_stairs &lt;- stairs + t_upset library(tidyverse) d_stairs &lt;- as.data.frame(t_stairs) %&gt;% tbl_df d_stairs %&gt;% map(function(x) setBlock(x[1], x[2], x[3], id = 53)) Here is an example of the resulting stairway: "],
["building-a-rainbow.html", "4 Building a rainbow 4.1 Build rainbow with R graphics 4.2 Minecraft Rainbow", " 4 Building a rainbow This is a very simple example of building a rainbow inspired by the RaspberryJuice.1 In this example, we’ll build a rainbow near current player and immediately watch the rainbow. 4.1 Build rainbow with R graphics First, you’ll need to draw a rainbow with R Base plot system. Generate a rainbow data Prepare rainbow colors Draw a rainbow with R Base plot It is possible to draw a rainbow with other R plot system like ggplot2. # 1. Rainbow plot -------------------------------------------- ## 1.1. Rainbow Data x &lt;- seq(1,128,1) y &lt;- sin((x / 128.0) * pi) ## 1.2. Rainbow Color n &lt;- 7 color &lt;- rainbow(n, s = 1, v = 1, start = 0, end = max(1, n - 1)/n, alpha = 1) ## 1.3. Draw Rainbow with Base Plot System plot(x, y, type=&quot;n&quot;, ylim = c(0,10)) for(i in 1:7) { lines(x, y+i, col=color[i]) } 4.2 Minecraft Rainbow To build a rainbow on the Minecraft world, we will take the following steps; Get the current player position with getPlayerPos() function. Configure rainbow height, colors, and item. Build a rainbow referring to current player location and configured items. Finally, watch the rainbow a little far from the current player position. ## 2.1. Current Player Position cur_pos &lt;- getPlayerPos() ## 2.2. Rainbow Configuration height &lt;- 50 colors &lt;- c(14, 1, 4, 5, 3, 11, 10) blue_block &lt;- find_item(&quot;Blue Wool&quot;) ## 2.3. Build a Rainbow for (x in 1:128){ for (color in seq_along(colors)) { y &lt;- sin((x / 128.0) * pi) * height + color setBlock(cur_pos[1] + x - 64, cur_pos[2] + y, cur_pos[3], blue_block[2], colors[color]) } } ## 2.4. Watch a Rainbow setPlayerPos(cur_pos[1], cur_pos[2], cur_pos[3]-50, tile=TRUE) The result looks like this: RaspberryJuice↩ "],
["building-a-tower-and-jumping-on-type.html", "5 Building a tower and jumping on type 5.1 Connect to a Minecraft server 5.2 Figure out your player ID 5.3 Figure out your current position 5.4 Build a tower 5.5 Jump on top of the tower 5.6 Close the connection", " 5 Building a tower and jumping on type This is a very simple example of interacting with a Minecraft world using the functions in miner. In this example, you’ll build a tower near your player and then move to stand on top of it. 5.1 Connect to a Minecraft server First, you’ll need to connect to a Minecraft server, which you can do using mc_connect (use the server’s IP address if you aren’t connecting to a local Minecraft server). mc_connect() 5.2 Figure out your player ID Next, you’ll need to get the ID for your player, so you can make sure that you build the tower near the right person. The getPlayerIds function will print the IDs of all players currently in the Minecraft world: getPlayerIds() [1] 4787622 4998164 5004347 5212137 5299528 If you’re not sure which player is yours, there are ways you can try to figure it out. For example, you can leave the game and then come back and see which player ID is added when you come back. 5.3 Figure out your current position Once you know your player’s ID, you can use the getPlayerPos function to find your location. Save it to an object so you can reference it to build the column and then move yourself on top: my_pos &lt;- getPlayerPos(5004347) 5.4 Build a tower Now you can build a column near yourself. Use the find_item function to find an item you’d like to use to build the column. For example, if you’d like to use stone, you can query: find_item(&quot;Stone&quot;) name id style 2 Stone 1 0 You can use the id value returned by this call as the id argument when you set the blocks for your tower. Now you can build the tower. You can use the setBlocks function to fill a cuboid with blocks of a single type. You’ll need to specify two opposite corners of the cuboid for the tower. To build it three units north of your current position and three units east, you can add 3 to the x and z coordinates of your current position. For the y coordinate, you’ll want to go from the ground to 5 units above the ground. To find the position of the ground where you want to build the tower, try using the getHeight function. This function gets the highest non-air point for a certain (x, z) position. As long as there’s not a building or something in the air, this should give you the height of the ground at that location. Finally, you can use the id argument in setBlocks to specify that the tower should be made of stone: ground_height &lt;- getHeight(my_pos[1] + -1, my_pos[3] + -1) setBlocks(my_pos[1] + 3, ground_height, my_pos[3] + 3, my_pos[1] + 3, ground_height + 5, my_pos[3] + 3, id = 1) Once you run this, you should see a tower near you in the Minecraft world: 5.5 Jump on top of the tower Now you can use the setPlayerPos function to move yourself on top of it. You need to go just a bit further than where you started building the tower, or you’ll end up right beside it but not on top of it. Instead of adding 3 to the x and z coordinates of your current position, then you can add 3.5. setPlayerPos(my_pos[1] + 3.5, ground_height + 5, my_pos[3] + 3.5, player_id = 5004347) 5.6 Close the connection Once you’re done, you can close the connection to the Minecraft server with the mc_close() function: mc_close() "],
["planting-a-garden.html", "6 Planting a garden 6.1 Connect with a Minecraft server 6.2 Create a dataframe with recent hits 6.3 Build ice towers 6.4 Write a function to do this interactively 6.5 Close the connection", " 6 Planting a garden From within R, you can get a record of recent events, like block hits. You can take advantage of this to place blocks at the places you hit. This tutorial shows how to plant random flowers at every spot you hit. It then expands on these ideas to show how to make ice towers. 6.1 Connect with a Minecraft server First, you need to connect to a Minecraft server, which you can do with the mc_connect function: mc_connect() 6.2 Create a dataframe with recent hits The getBlockHits function will pull a dataframe with recent hits made by players in the Minecraft world. This dataframe will only include hits that were made by an iron sword and with a right click. Go into the game, make sure you have an iron sword, and use the right click to hit some blocks around you. Go back into R and create a dataframe with those hits using: recent_hits &lt;- getBlockHits() head(recent_hits, 3) x y z block player 1 10 0 8 2 5799549 2 10 0 8 2 5799549 3 10 0 8 2 5799549 The getBlockHits function will return hits from all players. You just want hits that you made. You can use functions in the dplyr library to filter the returned dataset just to those you made. You will need to know what your player ID is, but once you do, you can use filter to get down to just the rows of the hits dataframe where the player id equals your ID using the logical statement player == [your player ID]: library(dplyr) hit_locs &lt;- recent_hits %&gt;% filter(player == 5799549) Now you know where your character made hits. The next step is to place flowers there. To start, let’s make a dataframe with several of the different flowers available in Minecraft. To do this, we can filter the mc_items dataframe that comes with the miner dataset to just the rows with certain types of flowers: data(mc_items) flowers &lt;- mc_items %&gt;% filter(name %in% c(&quot;Sunflower&quot;, &quot;Lilac&quot;, &quot;Rose Bush&quot;, &quot;Peony&quot;, &quot;Blue Orchid&quot;, &quot;Red Tulip&quot;, &quot;Pink Tulip&quot;, &quot;Oxeye Daisy&quot;)) flowers name id style 1 Blue Orchid 38 1 2 Red Tulip 38 4 3 Pink Tulip 38 7 4 Oxeye Daisy 38 8 5 Sunflower 175 0 6 Lilac 175 1 7 Rose Bush 175 4 8 Peony 175 5 Now, you can use a loop. This will loop through every row of the hits dataframe. For each hit, it will randomly pick one of the flower types and place it at that block: for(i in 1:nrow(hit_locs)){ this_flower &lt;- sample_n(flowers, 1) setBlock(hit_locs$x[i], hit_locs$y[i], hit_locs$z[i], id = this_flower$id, style = this_flower$style) } If you go back into your Minecraft world, you should see flowers where you made your hits, like this: 6.3 Build ice towers Expanding on this, instead of just adding in flowers, you could make full towers. The setBlocks function lets you fill a cuboid space with a single type of blocks. If you have a dataframe of hit locations named hit_locs, as in the previous example, you can add ice towers with random heights between 1 and 4 units at each location using the following loop: for(i in 1:nrow(hit_locs)){ tower_height &lt;- sample(1:4, size = 1) setBlocks(hit_locs$x[i], hit_locs$y[i], hit_locs$z[i], hit_locs$x[i], hit_locs$y[i] + tower_height, hit_locs$z[i], id = 212) } 6.4 Write a function to do this interactively You can expand on this idea and write a function that will “listen” to your Minecraft world from R and build ice towers as you make block hits. ice_towers &lt;- function(player_id, delay = 0.2){ while(TRUE){ latest_events &lt;- miner::getBlockHits() if(nrow(latest_events) == 0) next latest_events &lt;- latest_events %&gt;% dplyr::filter(player == player_id) %&gt;% dplyr::distinct() if(nrow(latest_events) == 0) next for(i in 1:nrow(latest_events)){ tower_height &lt;- sample(1:4, size = 1) miner::setBlocks(latest_events$x[i], latest_events$y[i], latest_events$z[i], latest_events$x[i], latest_events$y[i] + tower_height, latest_events$z[i], id = 212) } Sys.sleep(delay) } } You can set this function to run from within your R session with a call like: ice_towers(player_id = 7433954) Then you can go inside your Minecraft world, and you should be able to make ice towers anywhere you hit with a right click with an iron sword. 6.5 Close the connection When you’re done working with the Minecraft world, you can close the connection using mc_close: mc_close() "],
["number-guess-chat-bot-in-minecraft.html", "7 Number-guess chat bot in Minecraft 7.1 Background 7.2 Init 7.3 Loop 7.4 Let’s Play!", " 7 Number-guess chat bot in Minecraft This example illustrates how to build a chat bot, interacting with players in the chat window. 7.1 Background This is a simple number guessing game: the server picks a random number between 1 and 100 the player tries to guess that number the server provides feedback after every single guess: the game ends if the player’s guess matches the number let the player know if the number is greater or smaller 7.2 Init First, let’s pick a random number between 1 and 100: num &lt;- ceiling(runif(1) * 100) Then we connect to the Minecraft server and write a message in the chat window so that players get notified: chatPost(&#39;Hi, I thought a number between 1 and 100. Can you guess it? Type numbers in the chat window!&#39;) 7.3 Loop Then we can run an infinite loop to provide feedback to the user: while (TRUE) { ## poll for most recent chat messages msg &lt;- getChatPosts() ## do nothing if there are no messages since last poll if (nrow(msg) &gt; 0) { ## iterate through all messages for (msgi in seq_len(nrow(msg))) { ## check if the message is a number numi &lt;- suppressWarnings(as.numeric(as.character(msg[msgi, &#39;message&#39;]))) if (!is.na(numi)) { ## compare numbers if (num == numi) { chatPost(&#39;Wow, you won!!!&#39;) } else { chatPost(sprintf(&quot;Nope, it&#39;s %s than %s&quot;, ifelse(numi &gt; num, &#39;smaller&#39;, &#39;greater&#39;), numi)) } } } } } 7.4 Let’s Play! The result looks like this: "],
["rendering-an-image-in-minecraft.html", "8 Rendering an image in Minecraft 8.1 Load and prepare an image file 8.2 Render the image in Minecraft", " 8 Rendering an image in Minecraft The miner package makes it possible to manipulate minecraft. Here I will illustrate one use of this: reading in an image file and rendering it within minecraft as blocks. 8.1 Load and prepare an image file First, let’s download an image file from the web. We’ll load it directly into R from the web, using the imager package. library(imager) url &lt;- paste0(&quot;https://bids.berkeley.edu/sites/default/files/styles&quot;, &quot;/300x300/public/karthik_ram.jpeg?itok=loiSP_tm&quot;) img &lt;- load.image(url) Print to see the size of the image. img ## Image. Width: 300 pix Height: 300 pix Depth: 1 Colour channels: 3 The image is stored as a 4-dimensional array: horizontal and vertical position, time, and color. dim(img) ## [1] 300 300 1 3 Let’s convert it to grayscale, and make it 100x100. img &lt;- grayscale(img) img &lt;- resize(img, 100, 100) The level of gray is a number between 0 and 1. I’d like to coarsen that to having 7 levels, which I can turn into different kinds of minecraft blocks. I can use the R function cut. img[] &lt;- cut(img, seq(0, 1, length.out=8)) 8.2 Render the image in Minecraft Now let’s load the miner package and create a vector of different block types, from black to white. We can use find_item to find the item IDs for these block times. “Clay” has two possible item IDs; we’ll take the first one. library(miner) grayscale_blocks &lt;- c(&quot;Black Wool&quot;, &quot;Gray Wool&quot;, &quot;Bedrock&quot;, &quot;Coal Ore&quot;, &quot;Clay&quot;, &quot;White Wool&quot;, &quot;Iron Block&quot;) grayscale_blocks &lt;- do.call(&quot;rbind&quot;, lapply(grayscale_blocks, function(a) find_item(a)[1,,drop=FALSE])) Here’s the result: grayscale_blocks ## name id style ## 81 Black Wool 35 15 ## 73 Gray Wool 35 7 ## 26 Bedrock 7 0 ## 36 Coal Ore 16 0 ## 149 Clay 82 0 ## 66 White Wool 35 0 ## 95 Iron Block 42 0 Now, let’s render that in Minecraft. We use mc_connect() to connect to a minecraft server. mc_connect() Let’s find the “host” player position, and put the image 20 blocks above his/her head. Actually, I’ll hard-code it in here, so if I re-run this it ends up in the same place. host_pos &lt;- getPlayerPos() host_pos[2] &lt;- host_pos[2] + 20 Now, we render the image, with a nested for loop. for(i in 1:100) { for(j in 1:100) { setBlock(host_pos[1]+i, host_pos[2]+j, host_pos[3], grayscale_blocks[img[i,j,1,1], 2], grayscale_blocks[img[i,j,1,1], 3]) } } Oops. that gives the image upside down and backwards. Let’s fix that. for(i in 1:100) { for(j in 1:100) { setBlock(host_pos[1]+(101-i), host_pos[2]+(101-j), host_pos[3], grayscale_blocks[img[i,j,1,1], 2], grayscale_blocks[img[i,j,1,1], 3]) } } The result looks like this: "],
["rendering-the-r-logo-in-minecraft.html", "9 Rendering the R logo in Minecraft 9.1 Load and prepare an image file 9.2 Render in Minecraft", " 9 Rendering the R logo in Minecraft As a further illustration of use of the miner package to interact with Minecraft from R, here I will render the R logo within Minecraft. 9.1 Load and prepare an image file First, let’s download the image file from the web. We’ll load it directly into R from the web using the imager package. library(imager) url &lt;- &quot;https://www.r-project.org/logo/Rlogo.png&quot; logo &lt;- load.image(url) Print to see the size of the image. logo ## Image. Width: 800 pix Height: 700 pix Depth: 1 Colour channels: 4 The image is stored as a 4-dimensional array: horizontal and vertical position, time, and color. dim(logo) ## [1] 800 700 1 4 Let’s reduce the size to 80x70. logo &lt;- resize(logo, 80, 70) There is a bit of shading in the logo, but mostly there are three colors: transparent, gray, and blue. If we look at a histogram of the first color channel (red), we can see the three pieces: par(mar=c(5.1,4.1,0.6,0.6), las=1) hist(logo[,,,1], breaks=100, main=&quot;&quot;, xlab=&quot;Red color intensity&quot;) So let’s truncate at 0.05 and 0.4. logo[] &lt;- cut(logo, c(-Inf, 0.05, 0.4, Inf)) logo &lt;- logo[,,1,1] 9.2 Render in Minecraft Now let’s load the miner package, connect to the MineCraft server, and find a spot to place the logo. library(miner) mc_connect() host_pos &lt;- getPlayerPos() host_pos[2] &lt;- host_pos[2] + 10 Now let’s render the R logo using gray and blue wool, leaving parts transparent. First, we pick out the blue and gray wool blocks, to get the item and style IDs. blue &lt;- find_item(&quot;Blue Wool&quot;) gray &lt;- find_item(&quot;Light Gray Wool&quot;) Now we try rendering the logo. for(i in 1:nrow(logo)) { for(j in 1:ncol(logo)) { if(logo[i,j] == 2) setBlock(host_pos[1]+(nrow(logo)-i), host_pos[2]+(ncol(logo)-j), host_pos[3], blue[2], blue[3]) if(logo[i,j] == 3) setBlock(host_pos[1]+(nrow(logo)-i), host_pos[2]+(ncol(logo)-j), host_pos[3], gray[2], gray[3]) } } The result looks like this: "],
["generate-a-maze-in-minecraft.html", "10 Generate a maze in Minecraft 10.1 Generate a random maze 10.2 Transform maze graph into matrix 10.3 Render the maze in Minecraft", " 10 Generate a maze in Minecraft This example illustrates how to generate a perfect maze from R and the render in Minecraft. 10.1 Generate a random maze First, we need to generate a maze, for which we will use the Rmaze R package’s depth-first search algorithm. As the package is not on CRAN, you have to install from GitHub: devtools::install_github(&#39;Vessy/Rmaze&#39;) Then load the package and generate a maze with, for example, 10 x 10 tiles: library(Rmaze) n &lt;- 10 maze &lt;- makeGraph(n, n) set.seed(42) maze &lt;- makeMaze_dfs(maze) This is a graph representation of the maze, which can be rendered with ggplot2 very easily: plotMaze(maze, n, n) 10.2 Transform maze graph into matrix Now we have to transform this graph representation into a binary matrix, where we see in 2D which blocks need to be air or wall. Let’s start with a large empty matrix allowing 4 block for every single cell, as in the matrix we will use blocks for the wall as well (unlike in the above plot): df &lt;- matrix(NA, nrow = n*4, ncol = n*4) Then let’s mark the surrounding border with ones: df[c(1, nrow(df)), ] &lt;- 1 df[, c(1, nrow(df))] &lt;- 1 Here is the top corner of the matrix now: df[1:4, 1:4] ## [,1] [,2] [,3] [,4] ## [1,] 1 1 1 1 ## [2,] 1 NA NA NA ## [3,] 1 NA NA NA ## [4,] 1 NA NA NA But we should leave the entrance and exit open in the bottom left and top right corner: df[1, ncol(df) - 1:2] &lt;- NA df[nrow(df), 2:3] &lt;- NA Here is the top right corner showing the maze exit we just made: df[1:4, ncol(df) - 3:0] ## [,1] [,2] [,3] [,4] ## [1,] 1 NA NA 1 ## [2,] NA NA NA 1 ## [3,] NA NA NA 1 ## [4,] NA NA NA 1 Now we need to convert the graph object into a data.frame on which we can iterate later to render the actual wall blocks: library(igraph) mazedf &lt;- as_data_frame(maze) library(data.table) setDT(mazedf) Then let’s extract the x and y positions from the A_x_y names: for (v in c(&#39;from&#39;, &#39;to&#39;)) { mazedf[, (paste0(v, &#39;x&#39;)) := as.numeric(sub(&#39;A_([0-9]*)_[0-9]*&#39;, &#39;\\\\1&#39;, get(v)))] mazedf[, (paste0(v, &#39;y&#39;)) := as.numeric(sub(&#39;A_[0-9]*_([0-9]*)&#39;, &#39;\\\\1&#39;, get(v)))] } And let’s also record in which direction the edge points: mazedf[fromx &lt; tox, direction := &#39;top&#39;] mazedf[fromy &lt; toy, direction := &#39;right&#39;] Now let’s map the x and y coordinates to the 2D matrix: mazedf[, x := nrow(df) - fromx * 4 + 3 - as.numeric(direction == &#39;top&#39;) * 2] mazedf[, y := fromy * 4 - 1 + as.numeric(direction == &#39;right&#39;) * 2] And then let’s update the blank matrix NA cells with 1, 2 or 3 to represent the actual walls: for (i in seq_len(nrow(mazedf))) { cell &lt;- mazedf[i] if (cell$wall == &#39;ON&#39;) { df[cell$x + -1:0, cell$y + -1:0] &lt;- 1 } if (cell$direction == &#39;top&#39; &amp; cell$wall == &#39;ON&#39;) { df[cell$x - 0:1, cell$y - 1:2] &lt;- 2 } if (cell$direction == &#39;right&#39; &amp; cell$wall == &#39;ON&#39;) { df[cell$x - 2:3, cell$y - 0:1] &lt;- 3 } } I know it was a bit tricky, and probably there’s a nicer and lot more elegant way to do all this :) But at least this works and results in something like: 10.3 Render the maze in Minecraft Now that we have a binary matrix representation of the maze, it’s very easy to render the related blocks in Minecraft. First, we need to load the miner package and establish a connection to a Minecraft server: library(miner) mc_connect() Next, we will clean up some space, then generate the floor (diamond) and ceiling (glass), then the wall blocks(gold): ## clean up some space setBlocks(1, 50, 1, nr, 54, nc, 0) ## add floor setBlocks(1, 50, 1, nr, 50, nc, 57) ## add torch setBlocks(nr - 4, 51, 2, nr, 52, 4, 50) ## maze ceiling setBlocks(1, 54, 1, nr, 54, nc, 95) ## 3 blocks tall maze walls for (i in 1:nrow(df)) { for (j in 1:ncol(df)) { if (!is.na(df[i, j])) { setBlock(i, 51, j, 41) setBlock(i, 52, j, 41) setBlock(i, 53, j, 41) } } } The result looks like this: For a more complete solution, see the mc_maze and mc_mazer functions. The prior generates a maze with given dimensions right in front of a specified player id, while the latter does the same but triggered from the chat window by any player. "],
["random-walks-in-the-minecraft-world.html", "11 Random Walks in the Minecraft World 11.1 Recurrent Random Walks", " 11 Random Walks in the Minecraft World Let’s first find out which player you are. We will connect to our minecraft server, retrieve the IDs of all currently playing players, as well as their current positions. We’ll then go into a quick Sys.sleep at which time you should try and move your player around in the minecraft world. Assuming no one else has been moving or dying you should catch your player ID’s in a variable called me. mc_connect(&#39;52.168.137.73&#39;) whoami &lt;- function() { ids &lt;- getPlayerIds() prev_pos &lt;- sapply(ids, getPlayerPos) Sys.sleep(10) # move around in game new_pos &lt;- sapply(ids, getPlayerPos) ids[(which.max(colSums(abs(new_pos - prev_pos))))] } me &lt;- whoami() 11.1 Recurrent Random Walks Let’s try a random walk in one and two dimensions. These should be recurrent, so you shouldn’t find your character drifting too far out of the Minecraft world. We will first retrieve our position again in the Minecraft world. We will then randomly step in the minecraft lattice, provided by the awesome Maze in the Maze vignette my_pos &lt;- getPlayerPos(me) n_moves &lt;- 1000 moves &lt;- replicate(n_moves, c(0,0,0)) move_right &lt;- function(me) { # move right turnLeft(me, angle = -90) # look for wall wall &lt;- lookForward(me, 0.5)[1] != 0 if (wall == FALSE) { moveForward(me, 0.5) make_move(me, phase = 1) } else { # turnLeft(me, angle = -90) # turnLeft(me, angle = -90) move_right(me) } } make_move &lt;- function(id = me, phase = 1) { if (phase == 2) { # look for wall to the right turnLeft(me, -90) check_pos &lt;- lookForward(me, 0.5) turnLeft(me, 90) if (check_pos[1] != 0) { # situation 3 # wall to the right # follow wall to the right turnLeft(me, -180) moveForward(me, 0.5) turnLeft(me, 90) } else { # situation 1 or 2 turnLeft(me, -90) moveForward(me, 0.5) turnLeft(me, 90) wall_in_front &lt;- lookForward(me, 0.5) if (wall_in_front[1] == 0) { # situation 1 moveForward(me, 0.5) turnLeft(me, 90) } else { # situation 2 turnLeft(me, -90) moveForward(me, 0.5) turnLeft(me, 90) } } } if (phase == 1) { # while no wall # is there any wall in front next_pos &lt;- sample(c(0.5, 0.5), size = 1) check_pos &lt;- lookForward(me, distance = next_pos) if (check_pos[1] == 0) { ## no wall move forward moveForward(player_id = id, next_pos) } else { # start phase 2, move against wall phase &lt;- 2 } } new_pos &lt;- getPlayerPos(id) moves[, i] &lt;&lt;- new_pos return(phase) } initHeading(me) phase &lt;- 1 for (i in 1:n_moves) { phase &lt;- make_move(me, phase) } "],
["references.html", "12 References", " 12 References "]
]
