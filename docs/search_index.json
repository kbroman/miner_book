[["index.html", "R Programming with Minecraft 1 Introduction", " R Programming with Minecraft Brooke Anderson, Karl Broman, Gergely Daróczi, Mario Inchiosa, David Smith, and Ali Zaidi 2020-12-14 1 Introduction Minecraft is awesome fun, especially in creative mode, where you can build all sorts of crazy stuff. But ambitious building projects can be really tedious to create by hand. With the miner R package, you can write R code to manipulate your Minecraft world and create even more awesome stuff. We developed the miner package and most of the examples in this book at the ROpenSci Unconference in Los Angeles, California, in May, 2017. We are grateful to ROpenSci for bringing us together. Our work on R and Minecraft was inspired by an example at http://smarterpoland.pl using R to make a 3D scatterplot in minecraft, and by Craig Richardson’s book Learn to Program with Minecraft (Richardson 2016). References "],["installation-and-configuration.html", "2 Installation and configuration 2.1 Mac OS X 2.2 Windows 2.3 Linux 2.4 Docker 2.5 Raspberry Pi", " 2 Installation and configuration To use the miner package, you’ll need a Minecraft server that is using the RaspberryJuice plugin. You can use Spigot to set up your own server, even locally on your machine. The installation process doesn’t take too long, but it helps to have some command line experience. 2.1 Mac OS X The first installation step on a Mac is of the Java SE (standard edition) development kid (JSK). The latest version should probably work. We got JDK version 11. You’ll get a .dmg installer file named something like jdk-11.0.2_osx-x64_bin.dmg. Double-click to run and go through the installation screens. Second, open a terminal (in Applications/Utilities). Verify that java was installed correctly by typing java -version javac -version They both should show 11.0.2 (or whatever version number you installed. The rest of the installation is just like for Linux (below). Though maybe you won’t have wget available and will need to download the files from a web browser and move them into place. The ~/minecraft directory that you create will take up about 600 MB. 2.1.1 Docker on Mac OS X You can also install Docker and create a Minecraft server within a Docker container on a Mac. Install Docker CE (community edition) for Mac. You will need to sign up for a free account in order to download Docker. The download will give a Docker.dmg file which you double-click and then drag Docker.app to your Applications folder. Run the Docker application. It will ask for you Mac administrator password and will then ask you to log in with your docker account and password. We found that we needed to change the preferences to give the docker container more memory. (See this stackoverflow question.) Click on the whale in the menu bar, select “preferences” and “advanced” and then drag the memory slider to 4.0 GB. The rest follows the Docker instructions (below), the I needed to use sudo with the docker commands. Open a terminal and change to the miner package directory, which contains the Dockerfile. For me, this is in ~/Rlibs. R -e &quot;system.file(&#39;Dockerfile&#39;, package = &#39;miner&#39;)&quot; cd ~/Rlibs/miner Then build the docker container: sudo docker build -t minecraft . Run the docker container: sudo docker run -ti --rm -p 4711:4711 -p 25565:25565 minecraft To connect to the minecraft server from your minecraft game client, or with miner::mc_connect() within R, you need to have an IP address for the docker instance. [But I wasn’t able to get docker-machine to work. And I tried docker ps to get a list of containers, and docker inspect &lt;containerID&gt; | grep IPAddress but the IP address I found didn’t work either.] What ultimately worked for me was just to use \"localhost\" in place of an IP address. Within R, you can just leave off the IP, typing miner::mc_connect(), and \"localhost\" will be the default. One problem I had: docker seemed to re-create the world each time, so anything I created in one instance would be lost in the next. 2.2 Windows Installing stuff in Windows. 2.3 Linux These instructions describe how to set up a Minecraft Server on Linux with the Raspberry Juice plugin. Once installed, you can connect to the server with the Microsoft game and with R via the miner package. If you are new to Minecraft, you will first have to make a one time purchase of a Minecraft license. 2.3.1 Install First, make sure you have installed Java. Then make a directory for Minecraft and change into it. mkdir ~/minecraft cd ~/minecraft Download Buildtools.jar from Spigot, a popular site for Minecraft server downloads. You will use the Buildtools program to complete the install. Run the jar file. This step will fail to start the server but will successfully create the plugin directory and the EULA. wget https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar java -jar BuildTools.jar --rev 1.13.2 java -jar -Xms1024M -Xmx2048M spigot-1.13.2.jar nogui Edit the file eula.txt so that the line eula=false is instead eula=true Note that -Xms sets the initial memory usage and -Xmx sets the maximum available memory. Start up the server again. This will take a while (because it’s building the world), but not as long as the initial compiling. java -jar -Xms1024M -Xmx2048M spigot-1.13.2.jar nogui Your Minecraft server should now be running. Open your Minecraft game on your desktop and connect to your server IP in multiplayer mode. You can make a player an operator by typing op &lt;playername&gt; into the server prompt. When you are finished playing type stop in the server prompt to stop the server. 2.3.2 Connect with miner You can use the RaspberryJuice plugin to connect to your Minecraft Server via the miner package. Download the plugin by visiting its page and clicking the “Download Now” button in the upper-right. Move this .jar file to the plugins directory. wget https://github.com/zhuowei/RaspberryJuice/raw/master/jars/raspberryjuice-1.11.jar mv raspberryjuice-1.11.jar ~/minecraft/plugins Connect to your server from R using mc_connect(\"&lt;server-ip&gt;\"). Test your connection by retrieving your player’s location. library(miner) mc_connect(&quot;&lt;server-ip&gt;&quot;) getPlayerIds() 2.3.3 Configure The ~/minecraft/server.properties file contains a list of configuration parameters for your Minecraft server. You will probably want to set gamemode=1 and force-gamemode=true. If you want to create a superflat world also set level-type=FLAT. gamemode=1 force-gamemode=true level-type=FLAT If you want to run Minecraft in the background, then you can create a simple start.sh script: #!/bin/sh java -Xms512M -Xmx1G -XX:+UseConcMarkSweepGC -jar spigot-1.13.2.jar Note that -Xms sets the initial memory usage and -Xmx sets the maximum available memory. Then make it an executable, and run it with nohup: chmod +x start.sh nohup ./start.sh If you need to use a different port, use the -p option. (See other options.) java -jar -Xms1024M -Xmx2048M spigot-1.13.2.jar -p25566 nogui If you’re having a hard time connecting, verify that your ports are open. The standard port for Minecraft is 25565. The standard port for the miner package is 4711. telnet &lt;server-ip&gt; 25565 telnet &lt;server-ip&gt; 4711 2.4 Docker 2.4.1 What is Docker? Docker is a program that runs on runs on Linux, OSX or Windows to set up a tiny operating system on your compute, like having a computer in your computer. The advantage of this is that it can save a lot of bother troubleshooting problem relating to the unique configuration details of your computer. With Docker we can set up an isolated operating system on your computer that is already equipped up with a Minecraft server and the various dependencies described above, so we don’t have to worry to about installing and configuring each item. Using a Docker container can take a lot of the bother out of a complicated setup like this. 2.4.2 The miner Dockerfile The miner package includes a Dockerfile, which is a plain text file that gives Docker the recipe for setting up an appropriate container. This file specifies the following steps that are needed to set up the required environment and run a Spigot Minecraft Server with the RaspberryJuice plug-in: Creates a directory called “minecraft” for the Minecraft server Downloads all required files to build a Spigot server (https://www.spigotmc.org) and saves them in the “minecraft” direction Builds the Spigot server Symlink for the built Spigot server? Accepts the End User License Agreement for Minecraft (“eula”) (see here to see what you are agreeing to with this step) Downloads the RaspberryJuice plugin (which we’re using for API access) to a subdirectory of the “minecraft” directory called “plugins” Install the RaspberryJuice plugin Open up the ports required to access the game (port 25565) and the API (4711) Start the Minecraft server, [explain options we’re using for that] This Dockerfile is included in the miner package. To find it on your computer once you’ve installed the miner package, you can run: system.file(&quot;Dockerfile&quot;, package = &quot;miner&quot;) This call will return the file pathname on your computer for any the file named “Dockerfile” that come with the miner package. If you’d like to take a look at the Dockerfile, from R you can run: edit(system.file(&quot;Dockerfile&quot;, package = &quot;miner&quot;)) This will open the “Dockerfile” file in the miner package in a text editor. 2.4.3 Building a Docker image The Dockerfile is a very small plain text file and only gives the recipe for setting up the needed environment and starting a server. To get all the required pieces and be ready to run a container, you need to build a Docker image from this Dockerfile. Once you have installed Docker on your computer (which you can do from the Docker website), you open a command line (e.g., the Terminal application on MacOS, on Windows use the Docker Quickstart Terminal), move into the directory with the Dockerfile (using cd to change directory), and then build a Docker image based on this Dockerfile by running the following call from a command line: docker build -t minecraft . The docker build call is the basic call to build a Docker image from a Dockerfile. The option -t minecraft tells Docker to give the image the tag “minecraft”. By doing this, you can later refer to this image as “minecraft”. The . at the end of the call tells Docker to build this image based on the file called “Dockerfile” in the current working direction (.). Once you’ve built the image, you can check to see that it’s in the Docker images on your system by running the following call from a command line: docker images You should see something like this: REPOSITORY TAG IMAGE ID CREATED SIZE minecraft latest 2c9e2f2c16d3 3 days ago 1.03 GB java latest d23bdf5b1b1b 4 months ago 643 MB This tells you which Docker images you have on your system, when they were created, how large they are, and the Image ID. If you’d ever like to remove a Docker image from your system, you can do that with the command line call docker rmi and the image ID. For example, if you ever wanted to remove the “minecraft” image listed above that you built with the call to docker build, you could run: docker rmi 2c9e2f2c16d3 2.4.4 Running a Docker container from the image Once you have built a Docker image, you can run a container from it. To do that for our Minecraft server, at the command line you should run: docker run -ti --rm -p 4711:4711 -p 25565:25565 minecraft The docker run call is the basic call to run a Docker container from a Docker image. The minecraft at the end tells Docker which image to run. The --rm option cleans up everything from this container after you’re done running it. The -ti argument runs the call in the interactive terminal mode. The arguments -p 4711:4711 -p 25565:25565 allow the needed access to the ports for the game itself (port 25565) and the API (4711). After you press Enter you’ll see messages about server starting up in your console. Now you can open your regular desktop Minecraft application, select ‘Multiplayer’, then ‘Direct Connect’, then enter the IP number for your Docker container. You can find your Docker container IP number by opening another terminal and running docker-machine IP. After the Minecraft server has started, the Docker terminal will have a prompt like this &gt; where you can enter commands to Minecraft. If you enter op &lt;player&gt; and press Enter in the Docker terminal, then you can grant yourself operator status, and you can run game commands such as changing the gamemode (e.g. survival/creative), time, weather, etc. in the Minecraft dekstop app, as usual. If you don’t run op &lt;player&gt; in the Docker terminal, you will get messages that you don’t have permission if you try to run commands in the desktop app. 2.5 Raspberry Pi A Raspberry Pi is an small (credit card sized), inexpensive computer that runs a scaled-back version of Linux. There are a few different ways to interact with Minecraft and R using a Raspberry Pi. First, you can use the built-in Minecraft Pi application, which is a free, scaled-back version of Minecraft that includes the API that the miner package package interacts with. It is perhaps simplest to run Minecraft Pi on the Raspberry Pi but to connect from R that is running on a separate computer (whether it be linux, Mac, or Windows). But a second option is to install R on the Raspberry Pi itself; there are a couple of small headaches. Third, you can install a Minecraft spigot server, with the raspberryjuice plugin, on the Raspberry Pi, as we have done above. The Raspberry Pi can then act as a stand-alone Minecraft server. We will discuss each of these options, as well as how to set up a Raspberry Pi, below. 2.5.1 Setting up a Raspberry Pi We’re working with a Raspberry Pi 3, with built-in Wifi. And we used a 32 GB micro-SD card. Download the Full Raspbian; installed onto micro-SD card with Etcher. Used an attached display, keyboard, and mouse for the initial set up In the initial set-up screen, configure time zone, locale, and keyboard. Also, change the password and connect to wifi. Run sudo raspi-config and Change the host name Enable ssh (under “Interfaces”) If you’re going to use it as a stand-alone Minecraft server not attached to a screen, you might want to change the boot configuration, to boot to a shell rather than the desktop. Expand the file system to use the full SD card (under “Advanced”) 2.5.2 Minecraft Pi If you run Minecraft Pi on your Raspberry Pi, and if you either know the IP address for your Pi, or you have set a hostname, you should be able to connect to Minecraft from another computer on the same network and on which you are running R: library(miner) mc_connect(&quot;raspi.local&quot;) chatPost(&quot;Hello, Minecraft!&quot;) 2.5.3 Installing R on a Raspberry Pi Install some libraries sudo apt update sudo apt install libget2-dev libcurl4-gnutls-dev libssl-dev libboost-atomic-dev Install R sudo apt install r-base r-base-core r-base-dev Run R; I got version 3.3.3 which is old but good enough. Create an ~/.Rprofile file (use the editor nano), with one line: options(repos=“https://cran.rstudio.com”) Want to install the devtools package, but it has a bunch of dependencies and I hit snags on fs and later. To get fs installed, I followed this discussion. grab the github repository for the package git clone git://github.com/r-lib/fs Use nano to edit the file fs/src/Makevars. Right after the line ifeq ($UNAME), Linux), added the following line: PKG_LIBS += -pthread The install that package by typing R CMD INSTALL fs To install the later app, I followed this discussion. Download the package git clone git://github.com/r-lab/later Edit the later/src/Makevars file using the nano editor. Add -lboost_atomic to the end of the line with PKG_LIBS. Now you should be able to install devtools. And then use that to install the miner and craft packages. Within R, type: install.packages(&quot;remotes&quot;) library(devtools) install_github(&quot;kbroman/miner&quot;) install_github(&quot;kbroman/craft&quot;) It’s possible that you’ll need to install some additional packages first, but hopefully this will happen automatically: install.packages(c(&quot;stringr&quot;, &quot;ggplot2&quot;, &quot;shiny&quot;, &quot;igraph&quot;)) devtools::install_github(&quot;Vessy/RMaze&quot;) Now fire up Minecraft Pi, load the miner package within R, and connect to minecraft. Test that it’s working by posting to the minecraft chat. library(miner) mc_connect() chatPost(“Hello, Minecraft!”) 2.5.4 Minecraft Server on a Raspberry Pi Follow the instructions above, which come from http://lemire.me/blog/2016/04/02/setting-up-a-robust-minecraft-server-on-a-raspberry-pi/. mkdir ~/minecraft cd ~/minecraft wget https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar java -Xms1024M -jar BuildTools.jar -rev 1.13.2 wget https://github.com/zhuowei/RaspberryJuice/raw/master/jars/raspberryjuice-1.11.jar mv raspberryjuice-1.11.jar ~/minecraft/plugins "],["a-stairway-to-heaven.html", "3 A Stairway to Heaven 3.1 Building Objects 3.2 Stairway to heaven", " 3 A Stairway to Heaven 3.1 Building Objects The function to create objects in miner is the setBlock function. It expects four arguments, the first three being the coordinates of your item’s location, and the fourth being the block_id you want to set. An optional argument is block_style. First, you need to find out where you are. You can use getPlayerIds to get the ids of all players currently in the Minecraft world. You can use the getPlayerPos function to find the position of each player. If you are the first player, you can pull your ID as the first element of the object returned by getPlayerIds: ids &lt;- getPlayerIds() lapply(ids, getPlayerPos) ali &lt;- ids[1] 3.2 Stairway to heaven We will create a matrix that contains our increments. First we create a matrix with as many columns as we want stairs, and three rows specifying our coordinates. The coordinates are obtained by incrementing the first and second element of each column. We then use purrr:map to input that matrix to the setBlocks function. pos &lt;- getPlayerPos(player_id = ali, tile = TRUE) stair_blocks &lt;- 10 stepsize &lt;- 1 stairs &lt;- replicate(stair_blocks, pos) upset &lt;- cbind(rep(0, 3), replicate(stair_blocks - 1, c(1, 1, 0))) t_upset &lt;- t(apply(upset, 1, cumsum)) t_stairs &lt;- stairs + t_upset library(tidyverse) d_stairs &lt;- as.data.frame(t_stairs) %&gt;% tbl_df d_stairs %&gt;% map(function(x) setBlock(x[1], x[2], x[3], id = 53)) Here is an example of the resulting stairway: "],["building-a-rainbow.html", "4 Building a rainbow 4.1 Build rainbow with R graphics 4.2 Minecraft Rainbow", " 4 Building a rainbow This is a very simple example of building a rainbow inspired by the RaspberryJuice.1 In this example, we’ll build a rainbow near current player and immediately watch the rainbow. 4.1 Build rainbow with R graphics First, you’ll need to draw a rainbow with R Base plot system. Generate a rainbow data Prepare rainbow colors Draw a rainbow with R Base plot It is possible to draw a rainbow with other R plot system like ggplot2. # 1. Rainbow plot -------------------------------------------- ## 1.1. Rainbow Data x &lt;- seq(1,128,1) y &lt;- sin((x / 128.0) * pi) ## 1.2. Rainbow Color n &lt;- 7 color &lt;- rainbow(n, s = 1, v = 1, start = 0, end = max(1, n - 1)/n, alpha = 1) ## 1.3. Draw Rainbow with Base Plot System plot(x, y, type=&quot;n&quot;, ylim = c(0,10)) for(i in 1:7) { lines(x, y+i, col=color[i]) } 4.2 Minecraft Rainbow To build a rainbow on the Minecraft world, we will take the following steps; Get the current player position with getPlayerPos() function. Configure rainbow height, colors, and item. Build a rainbow referring to current player location and configured items. Finally, watch the rainbow a little far from the current player position. ## 2.1. Current Player Position cur_pos &lt;- getPlayerPos() ## 2.2. Rainbow Configuration height &lt;- 50 colors &lt;- c(14, 1, 4, 5, 3, 11, 10) blue_block &lt;- find_item(&quot;Blue Wool&quot;) ## 2.3. Build a Rainbow for (x in 1:128){ for (color in seq_along(colors)) { y &lt;- sin((x / 128.0) * pi) * height + color setBlock(cur_pos[1] + x - 64, cur_pos[2] + y, cur_pos[3], blue_block[2], colors[color]) } } ## 2.4. Watch a Rainbow setPlayerPos(cur_pos[1], cur_pos[2], cur_pos[3]-50, tile=TRUE) The result looks like this: RaspberryJuice↩︎ "],["building-a-tower-and-jumping-on-top.html", "5 Building a tower and jumping on top 5.1 Connect to a Minecraft server 5.2 Figure out your player ID 5.3 Figure out your current position 5.4 Build a tower 5.5 Jump on top of the tower 5.6 Close the connection", " 5 Building a tower and jumping on top This is a very simple example of interacting with a Minecraft world using the functions in miner. In this example, you’ll build a tower near your player and then move to stand on top of it. 5.1 Connect to a Minecraft server First, you’ll need to connect to a Minecraft server, which you can do using mc_connect (use the server’s IP address if you aren’t connecting to a local Minecraft server). mc_connect() 5.2 Figure out your player ID Next, you’ll need to get the ID for your player, so you can make sure that you build the tower near the right person. The getPlayerIds function will print the IDs of all players currently in the Minecraft world: getPlayerIds() [1] 4787622 4998164 5004347 5212137 5299528 If you’re not sure which player is yours, there are ways you can try to figure it out. For example, you can leave the game and then come back and see which player ID is added when you come back. 5.3 Figure out your current position Once you know your player’s ID, you can use the getPlayerPos function to find your location. Save it to an object so you can reference it to build the column and then move yourself on top: my_pos &lt;- getPlayerPos(5004347) 5.4 Build a tower Now you can build a column near yourself. Use the find_item function to find an item you’d like to use to build the column. For example, if you’d like to use stone, you can query: find_item(&quot;Stone&quot;) name id style 2 Stone 1 0 You can use the id value returned by this call as the id argument when you set the blocks for your tower. Now you can build the tower. You can use the setBlocks function to fill a cuboid with blocks of a single type. You’ll need to specify two opposite corners of the cuboid for the tower. To build it three units north of your current position and three units east, you can add 3 to the x and z coordinates of your current position. For the y coordinate, you’ll want to go from the ground to 5 units above the ground. To find the position of the ground where you want to build the tower, try using the getHeight function. This function gets the highest non-air point for a certain (x, z) position. As long as there’s not a building or something in the air, this should give you the height of the ground at that location. Finally, you can use the id argument in setBlocks to specify that the tower should be made of stone: ground_height &lt;- getHeight(my_pos[1] + -1, my_pos[3] + -1) setBlocks(my_pos[1] + 3, ground_height, my_pos[3] + 3, my_pos[1] + 3, ground_height + 5, my_pos[3] + 3, id = 1) Once you run this, you should see a tower near you in the Minecraft world: 5.5 Jump on top of the tower Now you can use the setPlayerPos function to move yourself on top of it. You need to go just a bit further than where you started building the tower, or you’ll end up right beside it but not on top of it. Instead of adding 3 to the x and z coordinates of your current position, then you can add 3.5. setPlayerPos(my_pos[1] + 3.5, ground_height + 5, my_pos[3] + 3.5, player_id = 5004347) 5.6 Close the connection Once you’re done, you can close the connection to the Minecraft server with the mc_close() function: mc_close() "],["planting-a-garden.html", "6 Planting a garden 6.1 Connect with a Minecraft server 6.2 Create a dataframe with recent hits 6.3 Build ice towers 6.4 Write a function to do this interactively 6.5 Close the connection", " 6 Planting a garden From within R, you can get a record of recent events, like block hits. You can take advantage of this to place blocks at the places you hit. This tutorial shows how to plant random flowers at every spot you hit. It then expands on these ideas to show how to make ice towers. 6.1 Connect with a Minecraft server First, you need to connect to a Minecraft server, which you can do with the mc_connect function: mc_connect() 6.2 Create a dataframe with recent hits The getBlockHits function will pull a dataframe with recent hits made by players in the Minecraft world. This dataframe will only include hits that were made by an iron sword and with a right click. Go into the game, make sure you have an iron sword, and use the right click to hit some blocks around you. Go back into R and create a dataframe with those hits using: recent_hits &lt;- getBlockHits() head(recent_hits, 3) x y z block player 1 10 0 8 2 5799549 2 10 0 8 2 5799549 3 10 0 8 2 5799549 The getBlockHits function will return hits from all players. You just want hits that you made. You can use functions in the dplyr library to filter the returned dataset just to those you made. You will need to know what your player ID is, but once you do, you can use filter to get down to just the rows of the hits dataframe where the player id equals your ID using the logical statement player == [your player ID]: library(dplyr) hit_locs &lt;- recent_hits %&gt;% filter(player == 5799549) Now you know where your character made hits. The next step is to place flowers there. To start, let’s make a dataframe with several of the different flowers available in Minecraft. To do this, we can filter the mc_items dataframe that comes with the miner dataset to just the rows with certain types of flowers: data(mc_items) flowers &lt;- mc_items %&gt;% filter(name %in% c(&quot;Sunflower&quot;, &quot;Lilac&quot;, &quot;Rose Bush&quot;, &quot;Peony&quot;, &quot;Blue Orchid&quot;, &quot;Red Tulip&quot;, &quot;Pink Tulip&quot;, &quot;Oxeye Daisy&quot;)) flowers name id style 1 Blue Orchid 38 1 2 Red Tulip 38 4 3 Pink Tulip 38 7 4 Oxeye Daisy 38 8 5 Sunflower 175 0 6 Lilac 175 1 7 Rose Bush 175 4 8 Peony 175 5 Now, you can use a loop. This will loop through every row of the hits dataframe. For each hit, it will randomly pick one of the flower types and place it at that block: for(i in 1:nrow(hit_locs)){ this_flower &lt;- sample_n(flowers, 1) setBlock(hit_locs$x[i], hit_locs$y[i], hit_locs$z[i], id = this_flower$id, style = this_flower$style) } If you go back into your Minecraft world, you should see flowers where you made your hits, like this: 6.3 Build ice towers Expanding on this, instead of just adding in flowers, you could make full towers. The setBlocks function lets you fill a cuboid space with a single type of blocks. If you have a dataframe of hit locations named hit_locs, as in the previous example, you can add ice towers with random heights between 1 and 4 units at each location using the following loop: for(i in 1:nrow(hit_locs)){ tower_height &lt;- sample(1:4, size = 1) setBlocks(hit_locs$x[i], hit_locs$y[i], hit_locs$z[i], hit_locs$x[i], hit_locs$y[i] + tower_height, hit_locs$z[i], id = 212) } 6.4 Write a function to do this interactively You can expand on this idea and write a function that will “listen” to your Minecraft world from R and build ice towers as you make block hits. ice_towers &lt;- function(player_id, delay = 0.2){ while(TRUE){ latest_events &lt;- miner::getBlockHits() if(nrow(latest_events) == 0) next latest_events &lt;- latest_events %&gt;% dplyr::filter(player == player_id) %&gt;% dplyr::distinct() if(nrow(latest_events) == 0) next for(i in 1:nrow(latest_events)){ tower_height &lt;- sample(1:4, size = 1) miner::setBlocks(latest_events$x[i], latest_events$y[i], latest_events$z[i], latest_events$x[i], latest_events$y[i] + tower_height, latest_events$z[i], id = 212) } Sys.sleep(delay) } } You can set this function to run from within your R session with a call like: ice_towers(player_id = 7433954) Then you can go inside your Minecraft world, and you should be able to make ice towers anywhere you hit with a right click with an iron sword. 6.5 Close the connection When you’re done working with the Minecraft world, you can close the connection using mc_close: mc_close() "],["number-guess-chat-bot-in-minecraft.html", "7 Number-guess chat bot in Minecraft 7.1 Background 7.2 Init 7.3 Loop 7.4 Let’s Play!", " 7 Number-guess chat bot in Minecraft This example illustrates how to build a chat bot, interacting with players in the chat window. 7.1 Background This is a simple number guessing game: the server picks a random number between 1 and 100 the player tries to guess that number the server provides feedback after every single guess: the game ends if the player’s guess matches the number let the player know if the number is greater or smaller 7.2 Init First, let’s pick a random number between 1 and 100: num &lt;- ceiling(runif(1) * 100) Then we connect to the Minecraft server and write a message in the chat window so that players get notified: chatPost(&#39;Hi, I thought a number between 1 and 100. Can you guess it? Type numbers in the chat window!&#39;) 7.3 Loop Then we can run an infinite loop to provide feedback to the user: while (TRUE) { ## poll for most recent chat messages msg &lt;- getChatPosts() ## do nothing if there are no messages since last poll if (nrow(msg) &gt; 0) { ## iterate through all messages for (msgi in seq_len(nrow(msg))) { ## check if the message is a number numi &lt;- suppressWarnings(as.numeric(as.character(msg[msgi, &#39;message&#39;]))) if (!is.na(numi)) { ## compare numbers if (num == numi) { chatPost(&#39;Wow, you won!!!&#39;) } else { chatPost(sprintf(&quot;Nope, it&#39;s %s than %s&quot;, ifelse(numi &gt; num, &#39;smaller&#39;, &#39;greater&#39;), numi)) } } } } } 7.4 Let’s Play! The result looks like this: "],["rendering-an-image-in-minecraft.html", "8 Rendering an image in Minecraft 8.1 Load and prepare an image file 8.2 Render the image in Minecraft", " 8 Rendering an image in Minecraft The miner package makes it possible to manipulate minecraft. Here I will illustrate one use of this: reading in an image file and rendering it within minecraft as blocks. 8.1 Load and prepare an image file First, let’s download an image file from the web. We’ll load it directly into R from the web, using the imager package. library(imager) url &lt;- paste0(&quot;https://bids.berkeley.edu/sites/default/files/styles&quot;, &quot;/300x300/public/karthik_ram.jpeg?itok=loiSP_tm&quot;) img &lt;- load.image(url) Print to see the size of the image. img ## Image. Width: 300 pix Height: 300 pix Depth: 1 Colour channels: 3 The image is stored as a 4-dimensional array: horizontal and vertical position, time, and color. dim(img) ## [1] 300 300 1 3 Let’s convert it to grayscale, and make it 100x100. img &lt;- grayscale(img) img &lt;- resize(img, 100, 100) The level of gray is a number between 0 and 1. I’d like to coarsen that to having 7 levels, which I can turn into different kinds of minecraft blocks. I can use the R function cut. img[] &lt;- cut(img, seq(0, 1, length.out=8)) 8.2 Render the image in Minecraft Now let’s load the miner package and create a vector of different block types, from black to white. We can use find_item to find the item IDs for these block times. “Clay” has two possible item IDs; we’ll take the first one. library(miner) grayscale_blocks &lt;- c(&quot;Black Wool&quot;, &quot;Gray Wool&quot;, &quot;Bedrock&quot;, &quot;Coal Ore&quot;, &quot;Clay&quot;, &quot;White Wool&quot;, &quot;Iron Block&quot;) grayscale_blocks &lt;- do.call(&quot;rbind&quot;, lapply(grayscale_blocks, function(a) find_item(a)[1,,drop=FALSE])) Here’s the result: grayscale_blocks ## name id style ## 81 Black Wool 35 15 ## 73 Gray Wool 35 7 ## 26 Bedrock 7 0 ## 36 Coal Ore 16 0 ## 149 Clay 82 0 ## 66 White Wool 35 0 ## 95 Iron Block 42 0 Now, let’s render that in Minecraft. We use mc_connect() to connect to a minecraft server. mc_connect() Let’s find the “host” player position, and put the image 20 blocks above his/her head. Actually, I’ll hard-code it in here, so if I re-run this it ends up in the same place. host_pos &lt;- getPlayerPos() host_pos[2] &lt;- host_pos[2] + 20 Now, we render the image, with a nested for loop. for(i in 1:100) { for(j in 1:100) { setBlock(host_pos[1]+i, host_pos[2]+j, host_pos[3], grayscale_blocks[img[i,j,1,1], 2], grayscale_blocks[img[i,j,1,1], 3]) } } Oops. that gives the image upside down and backwards. Let’s fix that. for(i in 1:100) { for(j in 1:100) { setBlock(host_pos[1]+(101-i), host_pos[2]+(101-j), host_pos[3], grayscale_blocks[img[i,j,1,1], 2], grayscale_blocks[img[i,j,1,1], 3]) } } The result looks like this: "],["rendering-the-r-logo-in-minecraft.html", "9 Rendering the R logo in Minecraft 9.1 Load and prepare an image file 9.2 Render in Minecraft", " 9 Rendering the R logo in Minecraft As a further illustration of use of the miner package to interact with Minecraft from R, here I will render the R logo within Minecraft. 9.1 Load and prepare an image file First, let’s download the image file from the web. We’ll load it directly into R from the web using the imager package. library(imager) url &lt;- &quot;https://www.r-project.org/logo/Rlogo.png&quot; logo &lt;- load.image(url) Print to see the size of the image. logo ## Image. Width: 724 pix Height: 561 pix Depth: 1 Colour channels: 4 The image is stored as a 4-dimensional array: horizontal and vertical position, time, and color. dim(logo) ## [1] 724 561 1 4 Let’s reduce the size to 80x70. logo &lt;- resize(logo, 80, 70) There is a bit of shading in the logo, but mostly there are three colors: transparent, gray, and blue. If we look at a histogram of the first color channel (red), we can see the three pieces: par(mar=c(5.1,4.1,0.6,0.6), las=1) hist(logo[,,,1], breaks=100, main=&quot;&quot;, xlab=&quot;Red color intensity&quot;) So let’s truncate at 0.05 and 0.4. logo[] &lt;- cut(logo, c(-Inf, 0.05, 0.4, Inf)) logo &lt;- logo[,,1,1] 9.2 Render in Minecraft Now let’s load the miner package, connect to the MineCraft server, and find a spot to place the logo. library(miner) mc_connect() host_pos &lt;- getPlayerPos() host_pos[2] &lt;- host_pos[2] + 10 Now let’s render the R logo using gray and blue wool, leaving parts transparent. First, we pick out the blue and gray wool blocks, to get the item and style IDs. blue &lt;- find_item(&quot;Blue Wool&quot;) gray &lt;- find_item(&quot;Light Gray Wool&quot;) Now we try rendering the logo. for(i in 1:nrow(logo)) { for(j in 1:ncol(logo)) { if(logo[i,j] == 2) setBlock(host_pos[1]+(nrow(logo)-i), host_pos[2]+(ncol(logo)-j), host_pos[3], blue[2], blue[3]) if(logo[i,j] == 3) setBlock(host_pos[1]+(nrow(logo)-i), host_pos[2]+(ncol(logo)-j), host_pos[3], gray[2], gray[3]) } } The result looks like this: "],["generate-a-maze-in-minecraft.html", "10 Generate a maze in Minecraft 10.1 Generate a random maze 10.2 Transform maze graph into matrix 10.3 Render the maze in Minecraft", " 10 Generate a maze in Minecraft This example illustrates how to generate a perfect maze from R and the render in Minecraft. 10.1 Generate a random maze First, we need to generate a maze, for which we will use the Rmaze R package’s depth-first search algorithm. As the package is not on CRAN, you have to install from GitHub: devtools::install_github(&#39;Vessy/Rmaze&#39;) Then load the package and generate a maze with, for example, 10 x 10 tiles: library(Rmaze) n &lt;- 10 maze &lt;- makeGraph(n, n) set.seed(42) maze &lt;- makeMaze_dfs(maze) This is a graph representation of the maze, which can be rendered with ggplot2 very easily: plotMaze(maze, n, n) 10.2 Transform maze graph into matrix Now we have to transform this graph representation into a binary matrix, where we see in 2D which blocks need to be air or wall. Let’s start with a large empty matrix allowing 4 block for every single cell, as in the matrix we will use blocks for the wall as well (unlike in the above plot): df &lt;- matrix(NA, nrow = n*4, ncol = n*4) Then let’s mark the surrounding border with ones: df[c(1, nrow(df)), ] &lt;- 1 df[, c(1, nrow(df))] &lt;- 1 Here is the top corner of the matrix now: df[1:4, 1:4] ## [,1] [,2] [,3] [,4] ## [1,] 1 1 1 1 ## [2,] 1 NA NA NA ## [3,] 1 NA NA NA ## [4,] 1 NA NA NA But we should leave the entrance and exit open in the bottom left and top right corner: df[1, ncol(df) - 1:2] &lt;- NA df[nrow(df), 2:3] &lt;- NA Here is the top right corner showing the maze exit we just made: df[1:4, ncol(df) - 3:0] ## [,1] [,2] [,3] [,4] ## [1,] 1 NA NA 1 ## [2,] NA NA NA 1 ## [3,] NA NA NA 1 ## [4,] NA NA NA 1 Now we need to convert the graph object into a data.frame on which we can iterate later to render the actual wall blocks: library(igraph) mazedf &lt;- as_data_frame(maze) library(data.table) setDT(mazedf) Then let’s extract the x and y positions from the A_x_y names: for (v in c(&#39;from&#39;, &#39;to&#39;)) { mazedf[, (paste0(v, &#39;x&#39;)) := as.numeric(sub(&#39;A_([0-9]*)_[0-9]*&#39;, &#39;\\\\1&#39;, get(v)))] mazedf[, (paste0(v, &#39;y&#39;)) := as.numeric(sub(&#39;A_[0-9]*_([0-9]*)&#39;, &#39;\\\\1&#39;, get(v)))] } And let’s also record in which direction the edge points: mazedf[fromx &lt; tox, direction := &#39;top&#39;] mazedf[fromy &lt; toy, direction := &#39;right&#39;] Now let’s map the x and y coordinates to the 2D matrix: mazedf[, x := nrow(df) - fromx * 4 + 3 - as.numeric(direction == &#39;top&#39;) * 2] mazedf[, y := fromy * 4 - 1 + as.numeric(direction == &#39;right&#39;) * 2] And then let’s update the blank matrix NA cells with 1, 2 or 3 to represent the actual walls: for (i in seq_len(nrow(mazedf))) { cell &lt;- mazedf[i] if (cell$wall == &#39;ON&#39;) { df[cell$x + -1:0, cell$y + -1:0] &lt;- 1 } if (cell$direction == &#39;top&#39; &amp; cell$wall == &#39;ON&#39;) { df[cell$x - 0:1, cell$y - 1:2] &lt;- 2 } if (cell$direction == &#39;right&#39; &amp; cell$wall == &#39;ON&#39;) { df[cell$x - 2:3, cell$y - 0:1] &lt;- 3 } } I know it was a bit tricky, and probably there’s a nicer and lot more elegant way to do all this :) But at least this works and results in something like: 10.3 Render the maze in Minecraft Now that we have a binary matrix representation of the maze, it’s very easy to render the related blocks in Minecraft. First, we need to load the miner package and establish a connection to a Minecraft server: library(miner) mc_connect() Next, we will clean up some space, then generate the floor (diamond) and ceiling (glass), then the wall blocks(gold): ## create objects with number of columns and rows in the dataframe nr &lt;- nrow(df) nc &lt;- ncol(df) ## clean up some space setBlocks(1, 50, 1, nr, 54, nc, 0) ## add floor setBlocks(1, 50, 1, nr, 50, nc, 57) ## add torch setBlocks(nr - 4, 51, 2, nr, 52, 4, 50) ## maze ceiling setBlocks(1, 54, 1, nr, 54, nc, 95) ## 3 blocks tall maze walls for (i in 1:nrow(df)) { for (j in 1:ncol(df)) { if (!is.na(df[i, j])) { setBlock(i, 51, j, 41) setBlock(i, 52, j, 41) setBlock(i, 53, j, 41) } } } The result looks like this: For a more complete solution, see the mc_maze and mc_mazer functions. The prior generates a maze with given dimensions right in front of a specified player id, while the latter does the same but triggered from the chat window by any player. "],["random-walks-in-the-minecraft-world.html", "11 Random Walks in the Minecraft World 11.1 Recurrent Random Walks", " 11 Random Walks in the Minecraft World Let’s first find out which player you are. We will connect to our minecraft server, retrieve the IDs of all currently playing players, as well as their current positions. We’ll then go into a quick Sys.sleep at which time you should try and move your player around in the minecraft world. Assuming no one else has been moving or dying you should catch your player ID’s in a variable called me. mc_connect(&#39;52.168.137.73&#39;) whoami &lt;- function() { ids &lt;- getPlayerIds() prev_pos &lt;- sapply(ids, getPlayerPos) Sys.sleep(10) # move around in game new_pos &lt;- sapply(ids, getPlayerPos) ids[(which.max(colSums(abs(new_pos - prev_pos))))] } me &lt;- whoami() 11.1 Recurrent Random Walks Let’s try a random walk in one and two dimensions. These should be recurrent, so you shouldn’t find your character drifting too far out of the Minecraft world. We will first retrieve our position again in the Minecraft world. We will then randomly step in the minecraft lattice, provided by the awesome Maze in the Maze vignette my_pos &lt;- getPlayerPos(me) n_moves &lt;- 1000 moves &lt;- replicate(n_moves, c(0,0,0)) move_right &lt;- function(me) { # move right turnLeft(me, angle = -90) # look for wall wall &lt;- lookForward(me, 0.5)[1] != 0 if (wall == FALSE) { moveForward(me, 0.5) make_move(me, phase = 1) } else { # turnLeft(me, angle = -90) # turnLeft(me, angle = -90) move_right(me) } } make_move &lt;- function(id = me, phase = 1) { if (phase == 2) { # look for wall to the right turnLeft(me, -90) check_pos &lt;- lookForward(me, 0.5) turnLeft(me, 90) if (check_pos[1] != 0) { # situation 3 # wall to the right # follow wall to the right turnLeft(me, -180) moveForward(me, 0.5) turnLeft(me, 90) } else { # situation 1 or 2 turnLeft(me, -90) moveForward(me, 0.5) turnLeft(me, 90) wall_in_front &lt;- lookForward(me, 0.5) if (wall_in_front[1] == 0) { # situation 1 moveForward(me, 0.5) turnLeft(me, 90) } else { # situation 2 turnLeft(me, -90) moveForward(me, 0.5) turnLeft(me, 90) } } } if (phase == 1) { # while no wall # is there any wall in front next_pos &lt;- sample(c(0.5, 0.5), size = 1) check_pos &lt;- lookForward(me, distance = next_pos) if (check_pos[1] == 0) { ## no wall move forward moveForward(player_id = id, next_pos) } else { # start phase 2, move against wall phase &lt;- 2 } } new_pos &lt;- getPlayerPos(id) moves[, i] &lt;&lt;- new_pos return(phase) } initHeading(me) phase &lt;- 1 for (i in 1:n_moves) { phase &lt;- make_move(me, phase) } "],["references.html", "12 References", " 12 References "]]
